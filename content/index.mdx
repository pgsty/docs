---
title: Pigsty Docs
description: Pigsty v3.6 Documentation
icon: PiggyBank
full: true
---

<span className="text-sky-700 font-black">P</span>ostgres <span className="text-blue-400 font-black">I</span>n <span className="text-orange-500 font-black">G</span>reat <span className="text-gray-500 font-black">S</span><span className="text-red-700 font-black">T</span><span className="text-green-600 font-black">Y</span>le ——
<span className="text-sky-700 font-black">P</span>ostgres
<span className="text-blue-400 font-black">I</span>nfra
<span className="text-orange-500 font-black">G</span>raphic
<span className="text-gray-500 font-black">S</span>ervice
<span className="text-red-700 font-black">T</span>oolbox, 
<span className="text-green-600 font-black">Y</span>ours

import {Database,CpuIcon,Landmark,Settings,Container,Leaf,Box,Layers,Rocket,SquareStack,Code} from 'lucide-react';


## Introduction

<span className="text-black font-black">Pigsty</span> <span className="text-fd-muted-foreground text-sm">(/ˈpɪɡ staɪ/)</span>
is a Battery-Included, FOSS <a href="/intro/distro"><span className="text-sky-700 font-black">PostgreSQL Distribution</span></a>
as a Local-First <a href="/intro/rds"><span className="text-amber-600 font-black">RDS Alternative</span></a>.

<Cards>

    <Card icon={<Rocket className="text-blue-300" />} title='Values' href={"/value"}>
        Why use Pigsty?
        The 8 core value propositions of Pigsty
    </Card>

    <Card icon={<SquareStack className={"text-red-500"} />} title='Features' href={"/feat"}>
        Key features, Highlights and Technical details
    </Card>

    <Card icon={<Code className="text-green-600" />} title='References' href={"/intro"}>
        Architecture, Use Cases, Comparisons, and other references
    </Card>
    <Card icon={<Landmark className={"text-orange-400"} />} title='About' href={"/about"}>
        License, Release, Community, News, Author, Service, etc...
    </Card>

</Cards>

Pigsty assembles all the superpowers from the PostgreSQL and Database world, provides everything you'll need to build your own Data Infra.

> **Just use Postgres for Everything! and Self-Hosting it like a Pro!**



--------

## Installation

[**Quick Start**](/install/start): [Prepare](/prepare) an [ssh-accessible](/prepare/admin#check-accessibility) [node](/prepare/hardware#node) with fresh installed [Linux](/prepare/linux),
run as [user](/prepare/admin#user) with nopass [`ssh`](/prepare/admin#ssh) and [`sudo`](/prepare/admin#sudo-privileges) privileges:

```bash title="install"
curl -fsSL https://repo.pigsty.io/get | bash;
cd ~/pigsty; ./configure; ./install.yml;
```

[**Download**](/prepare/software#pigsty), [**Configure**](/config/configure) and [**Install**](/install). Pigsty [**Installed**](/install)! You can [**add more**](/install/multinode) nodes and database clusters later.

Explore the [**User Interface**](/install/interface), check port `5432` for [Postgres](/pgsql) [Service](/pgsql/service), port `3000` for grafana dashboards (userpass: `admin` / `pigsty`).

<Cards>

    <Card icon={<Rocket className="text-blue-300" />} title='Installation' href={"/install"}>
        Install Pigsty on Linux Servers
    </Card>

    <Card icon={<SquareStack className={"text-red-500"} />} title='Preparation' href={"/prepare"}>
        Prepare Environment for Serious Deployment
    </Card>

    <Card icon={<Code className="text-green-600" />} title='Configuration' href={"/config"}>
        Customize database clusters with Config Inventory
    </Card>
    <Card icon={<Landmark className={"text-orange-400"} />} title='Administration' href={"/admin"}>
        Manage your environment with Ansible Playbook
    </Card>

</Cards>

You can also wrap exotic [PostgreSQL](/pgsql/kernel/postgres) kernels into RDS: [Citus](/pgsql/kernel/citus), [WiltonDB](/pgsql/kernel/babelfish), [IvorySQL](/pgsql/kernel/ivorysql), [OpenHalo](/pgsql/kernel/openhalo), [Percona](/pgsql/kernel/percona), [OrioleDB](/pgsql/kernel/orioledb), [PolarDB](/pgsql/kernel/polardb), and [Supabase](/pgsql/kernel/supabase).

--------

## Modules

Pigsty consists of multiple [**Modules**](/intro/module). The `PINE` stack: `PGSQL` / `INFRA` / `NODE` / `ETCD` are <span className="text-sky-700 font-black">REQUIRED</span> for self-hosting Postgres RDS service.

<Cards>
    <Card icon={<Database className="text-sky-600" />} title='PGSQL' href={"/pgsql"}>
        HA PG Cluster with HA, PITR, IaC, ACL, Monitor, and 437 extensions
    </Card>
    <Card icon={<Landmark className="text-green-700" />} title='INFRA' href={"/infra"}>
        Nginx, Repo, DNS, NTP, Prometheus and Grafana stack for Observability
    </Card>
    <Card icon={<CpuIcon className={"text-amber-500"} />} title='NODE' href={"/node"}>
        Enroll nodes into the desired state and monitor it, and VIP, HAProxy
    </Card>
    <Card icon={<Settings className={"text-sky-400"} />} title='ETCD' href={"/etcd"}>
        Reliable distributive consensus storage (DCS), empowering PGSQL HA
    </Card>
</Cards>

Pigsty also has some <span className="text-emerald-500 font-black">OPTIONAL</span> "Bonus" modules, which work well with PostgreSQL, and bring extra value to your data infrastructure.

<Cards>
    <Card icon={<Box className="text-red-800" />} title='MINIO' href={"/minio"}>
        S3 compatible object storage compatible, optional backup storage
    </Card>
    <Card icon={<Layers className="text-red-400" />} title='REDIS' href={"/redis"}>
        High-performance in-memory cache, optional data structure server
    </Card>
    <Card icon={<Container className="text-blue-500" />} title='DOCKER' href={"/docker"}>
        Container runtime, optional for running stateless app and tools
    </Card>
    <Card icon={<Leaf className="text-gray-500" />} title='FERRET' href={"/ferret"}>
        MongoDB wire-protocol compatible on PostgreSQL, optional middleware
    </Card>
</Cards>




--------

## FAQ

import { Accordion, Accordions } from 'fumadocs-ui/components/accordion';

<Accordions type="single" orientation={"horizontal"}>
    <Accordion title="What is Pigsty—and what isn't it?">
        Pigsty is a PostgreSQL distribution: an open-source, local-first RDS-like solution. It isn't a database (DBMS), but rather a management tool, solution, and set of best practices. Think of a database as a car, a DBA as the driver, RDS as a taxi service, and Pigsty as self-driving software.
    </Accordion>
    
    <Accordion title="What problem does Pigsty solve?">
        Database expertise is scarce and costly—you either hire expensive DBAs or pay a premium for cloud RDS. Now there's a new option: Pigsty (the "self-driving" equivalent). It lets you run databases without a dedicated DBA at under one-tenth the cost of typical RDS, while achieving greater performance and flexibility in a local cloud environment.
    </Accordion>
    
    <Accordion title="Why can Pigsty help you manage databases effectively?">
        Pigsty packages hard-earned best practices from large, complex PostgreSQL deployments into a reproducible solution. It tackles everything: scalable installs, high availability, connection pooling, monitoring, backup/recovery, parameter tuning, IaC-based cluster management, one-click deployment, and automated ops—letting you avoid common pitfalls and reinventing the wheel.
    </Accordion>
    
    <Accordion title="Why is Pigsty better than RDS?">
        Pigsty provides a richer feature set than most RDS offerings: 400+ extensions, support for 9+ Postgres kernels, a unique monitoring system, and proven architecture refined by top-tier enterprise use (Apple, Alibaba, Tantan). It's easy to use, deeply tested, and fueled by genuine passion—at a depth and maturity level typical RDS platforms can't match.
    </Accordion>
    
    <Accordion title="Why is Pigsty more cost-effective than RDS?">
        With Pigsty, you can run what's effectively a ¥400–¥1400/core/month RDS instance on bare-metal resources costing as little as ¥10/core/month—and skip paying a DBA's salary. At scale, total cost of ownership can drop by 90% or more. Pigsty slashes license, service, and personnel costs, so you can channel your budget where it really matters.
    </Accordion>
    
    <Accordion title="How does Pigsty help developers?">
        Pigsty integrates 400+ PG extensions for an all-in-Postgres approach—letting you replace Redis, Kafka, MySQL, Elasticsearch, vector databases, and even certain OLAP/big-data use cases with one stack. This boosts developer agility, cuts complexity, and enables self-serve DevOps without needing a dedicated DBA.
    </Accordion>
    
    <Accordion title="How does Pigsty help operations teams?">
        Pigsty's self-healing HA ensures you don't need to scramble when hardware fails—ops and DBAs can sleep easy. Advanced monitoring aids troubleshooting and performance tuning. IaC automates large-scale cluster management. Ops can double as DBAs, and DBAs skip heavy lifting to focus on high-value tasks—or just enjoy a tea break while learning PG.
    </Accordion>
    
    <Accordion title="Who created Pigsty?">
        Pigsty is primarily developed by @Vonng / Ruohang Feng, a PostgreSQL veteran with a decade of open-source contributions and production experience at Alibaba, Tantan, and Apple. He's the founder of a one-person company (YC China/MiraclePlus S22) offering professional postgres consultancy. He's also a top database/cloud KOL with over 100k followers.
    </Accordion>
    
    <Accordion title="What is Pigsty's ecosystem standing and impact?">
        Pigsty is one of the most active OSS projects in the PG ecosystem (OSSRank). It prevails in extension distribution and monitoring solutions, positioning itself as a challenger to cloud RDS. It's already in wide use across military, government, healthcare, internet, finance, and manufacturing sectors.
    </Accordion>
    
    <Accordion title="Which user scale is Pigsty suitable for?">
        Pigsty was built for massive PostgreSQL clusters, but it's also optimized for simplicity. Even solo developers or small businesses without DBA skills can get going easily. Largest known production scale: 25k vCPUs at 4.5 million QPS over six years. Smallest: a 1c1g VM demo or dev box.
    </Accordion>
    
    <Accordion title="Which capabilities does Pigsty offer?">
        Pigsty focuses on Postgres best practices and integrates well with complementary open-source tools like Etcd, Redis, MinIO, DuckDB, Prometheus, FerretDB, Babelfish, IvorySQL, PolarDB, OrioleDB, OpenHalo, Supabase, Greenplum, Dify, Odoo, and more.
    </Accordion>
    
    <Accordion title="Which scenarios does Pigsty fit?">
        Massive production postgres deployment, self-hosting RDS, object storage, caching, data warehousing, Supabase, etc. It can run enterprise apps like Odoo, Dify, wikis, GitLab, or serve as a monitoring hub for existing nodes and DBMS. It also excels at combining multiple PG extensions, powering interactive data apps, data visualization, and websites.
    </Accordion>
    
    <Accordion title="Is Pigsty open source and free?">
        Yes. Pigsty is 100% free software under the AGPLv3 license. You can use it freely for commercial purposes if you comply with that license. We value software freedom; for non-DBaaS/OEM use, we apply an Apache 2.0–like approach. See the license for details.
    </Accordion>
    
    <Accordion title="Does Pigsty offer commercial support?">
        Pigsty itself is free, but we provide commercial subscriptions for those who want assurance and expert support. Subscriptions extend coverage to more OS/PG/CPU architectures, plus consultancy. This delivers top-tier technical expertise and solutions, saving you time, reducing risk, and covering tough issues.
    </Accordion>
    
    <Accordion title="Can Pigsty be repackaged as multi-tenant DBaaS or rebranded?">
        Yes, under the AGPLv3 license—meaning any derivative work must be open-sourced. We reserve the right to pursue violations by public cloud/database vendors. If you prefer not to open-source derivatives, consider Pigsty Service Subscriptions, which provide explicit licensing and an AGPLv3 exemption for this scenario.
    </Accordion>
</Accordions>


